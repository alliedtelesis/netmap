diff --git a/ice/ice_base.c b/ice/ice_base.c
index e864634d66bc..6fd0dbc293f7 100644
--- a/ice/ice_base.c
+++ b/ice/ice_base.c
@@ -7,6 +7,11 @@
 #include "ice_dcb_lib.h"
 #include "ice_sriov.h"
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_ICE_BASE
+#include <ice_netmap_linux.h>
+#endif
+
 /**
  * __ice_vsi_get_qs_contig - Assign a contiguous chunk of queues to VSI
  * @qs_cfg: gathered variables needed for PF->VSI queues assignment
@@ -448,6 +453,10 @@ static int ice_setup_rx_ctx(struct ice_rx_ring *ring)
 	/* Rx queue threshold in units of 64 */
 	rlan_ctx.lrxqthresh = 1;
 
+#ifdef DEV_NETMAP
+	ice_netmap_preconfigure_rx_ring(ring, &rlan_ctx);
+#endif /* DEV_NETMAP */
+
 	/* Enable Flexible Descriptors in the queue context which
 	 * allows this driver to select a specific receive descriptor format
 	 * increasing context priority to pick up profile ID; default is 0x01;
@@ -564,6 +573,11 @@ int ice_vsi_cfg_rxq(struct ice_rx_ring *ring)
 
 		return 0;
 	}
+    
+#ifdef DEV_NETMAP
+	if (ice_netmap_configure_rx_ring(ring))
+		return 0;
+#endif /* DEV_NETMAP */
 
 	ice_alloc_rx_bufs(ring, num_bufs);
 
@@ -830,6 +844,10 @@ ice_vsi_cfg_txq(struct ice_vsi *vsi, struct ice_tx_ring *ring,
 	txq = &qg_buf->txqs[0];
 	if (pf_q == le16_to_cpu(txq->txq_id))
 		ring->txq_teid = le32_to_cpu(txq->q_teid);
+    
+#ifdef DEV_NETMAP
+	ice_netmap_configure_tx_ring(ring);
+#endif /* DEV_NETMAP */
 
 	return 0;
 }
diff --git a/ice/ice_main.c b/ice/ice_main.c
index cfc57cfc46e4..ac1eaad2b5a1 100644
--- a/ice/ice_main.c
+++ b/ice/ice_main.c
@@ -36,6 +36,11 @@ MODULE_DESCRIPTION(DRV_SUMMARY);
 MODULE_LICENSE("GPL v2");
 MODULE_FIRMWARE(ICE_DDP_PKG_FILE);
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_ICE_LIB
+#include <ice_netmap_linux.h>
+#endif
+
 static int debug = -1;
 module_param(debug, int, 0644);
 #ifndef CONFIG_DYNAMIC_DEBUG
@@ -5061,7 +5066,9 @@ static void ice_remove(struct pci_dev *pdev)
 {
 	struct ice_pf *pf = pci_get_drvdata(pdev);
 	int i;
-
+#ifdef DEV_NETMAP
+	ice_netmap_detach(pf);
+#endif /* DEV_NETMAP */
 	ice_devlink_unregister(pf);
 	for (i = 0; i < ICE_MAX_RESET_WAIT; i++) {
 		if (!ice_is_reset_in_progress(pf->state))
@@ -5203,7 +5210,9 @@ static int ice_reinit_interrupt_scheme(struct ice_pf *pf)
 			ret);
 		goto err_reinit;
 	}
-
+#ifdef DEV_NETMAP
+	ice_netmap_attach(pf);
+#endif
 	return 0;
 
 err_reinit:
diff --git a/ice/ice_txrx.c b/ice/ice_txrx.c
index dbe80e5053a8..b65e5810dc2c 100644
--- a/ice/ice_txrx.c
+++ b/ice/ice_txrx.c
@@ -23,6 +23,10 @@
 #define FDIR_DESC_RXDID 0x40
 #define ICE_FDIR_CLEAN_DELAY 10
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#include <ice_netmap_linux.h>
+#endif
+
 /**
  * ice_prgm_fdir_fltr - Program a Flow Director filter
  * @vsi: VSI to send dummy packet
@@ -1120,6 +1124,16 @@ int ice_clean_rx_irq(struct ice_rx_ring *rx_ring, int budget)
 	struct xdp_buff xdp;
 	bool failure;
 
+#ifdef DEV_NETMAP
+	if (rx_ring->netdev) {
+		int dummy, nm_irq;
+		nm_irq = netmap_rx_irq(rx_ring->netdev, rx_ring->q_index, &dummy);
+		if (nm_irq != NM_IRQ_PASS) {
+			return 1;
+		}
+	}
+#endif /* DEV_NETMAP */
+
 	/* Frame size depend on rx_ring setup when PAGE_SIZE=4K */
 #if (PAGE_SIZE < 8192)
 	frame_sz = ice_rx_frame_truesize(rx_ring, 0);
@@ -2447,6 +2461,10 @@ void ice_clean_ctrl_tx_irq(struct ice_tx_ring *tx_ring)
 	int budget = ICE_DFLT_IRQ_WORK;
 	struct ice_tx_desc *tx_desc;
 	struct ice_tx_buf *tx_buf;
+#ifdef DEV_NETMAP
+    if (tx_ring->netdev && netmap_tx_irq(tx_ring->netdev, tx_ring->q_index) != NM_IRQ_PASS)
+        return;
+#endif /* DEV_NETMAP */
 
 	tx_buf = &tx_ring->tx_buf[i];
 	tx_desc = ICE_TX_DESC(tx_ring, i);
